/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthBase {
  private accessToken: string;
  constructor(accessToken: string) {
    this.accessToken = accessToken;
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.accessToken) {
      (<Record<string, string>>options.headers).Authorization =
        "Bearer " + this.accessToken;
      return Promise.resolve(options);
    }
    return Promise.resolve(options);
  }
}

export class ClientBase {
  constructor(private AuthBase: AuthBase) {}

  private cacheableResponse = false;
  private cacheStrategy: "CacheFirst" | "NetworkFirst" = "NetworkFirst";
  private cacheAllowStatuses: number[] = [200];
  private cacheableOptions: RequestInit = null;

  setCacheableResponse(
    cacheStrategy: ClientBase["cacheStrategy"] = "NetworkFirst",
    cacheAllowStatuses: ClientBase["cacheAllowStatuses"] = [200]
  ) {
    this.cacheableResponse = true;
    this.cacheStrategy = cacheStrategy;
    this.cacheAllowStatuses = cacheAllowStatuses;
  }

  async transformOptions(options: RequestInit): Promise<RequestInit> {
    const result = await (this.AuthBase
      ? this.AuthBase.transformHttpRequestOptions(options)
      : Promise.resolve(options));

    if (this.cacheableResponse) {
      this.cacheableOptions = result;
    }

    return result;
  }

  private async cacheResponse(
    request: Request,
    response: Response
  ): Promise<Response> {
    const cache = await caches.open("nswagts.v1");
    const cloned = response.clone();
    await cache.put(request, response);

    return cloned;
  }

  async transformResult(
    url: string,
    networkResponse: Response,
    cb: (response: Response) => any
  ) {
    let response: Response = networkResponse;
    if (process.browser && this.cacheableResponse) {
      console.debug("NswagTs transformResult cacheableResponse executing...");
      const request = new Request(url, this.cacheableOptions);

      const cacheResponse = await caches.match(request);

      const networkOk = this.cacheAllowStatuses.includes(
        networkResponse?.status ?? 0
      );
      const cacheOk = this.cacheAllowStatuses.includes(
        cacheResponse?.status ?? 0
      );

      if (this.cacheStrategy === "CacheFirst") {
        if (cacheOk) {
          console.debug(
            "NswagTs transformResult cacheableResponse cache first using cache",
            cacheResponse
          );
          response = cacheResponse;
        } else {
          console.debug(
            "NswagTs transformResult cacheableResponse cache first using network",
            networkResponse
          );
          response = networkOk
            ? await this.cacheResponse(request, networkResponse)
            : networkResponse;
        }
      } else if (this.cacheStrategy === "NetworkFirst") {
        if (networkOk) {
          console.debug(
            "NswagTs transformResult cacheableResponse network first using network ok",
            networkResponse
          );
          response = await this.cacheResponse(request, networkResponse);
        } else if (cacheOk) {
          console.debug(
            "NswagTs transformResult cacheableResponse network first using cache",
            cacheResponse
          );
          response = cacheResponse;
        } else {
          console.debug(
            "NswagTs transformResult cacheableResponse network first using network failure",
            networkResponse
          );
          response = networkResponse;
        }
      }
    }
    this.cacheableResponse = false;
    return cb(response);
  }
}

export interface IAuthClient {
    login(command: LoginCommand): Promise<UserTokenDto>;
    checkAuth(): Promise<UserDto>;
    sendMailToResetPassword(email: string): Promise<FileResponse>;
}

export class AuthClient extends ClientBase implements IAuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthBase, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(command: LoginCommand): Promise<UserTokenDto> {
        let url_ = this.baseUrl + "/api/Auth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogin(_response));
        });
    }

    protected processLogin(response: Response): Promise<UserTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTokenDto>(<any>null);
    }

    checkAuth(): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/Auth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCheckAuth(_response));
        });
    }

    protected processCheckAuth(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }

    sendMailToResetPassword(email: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Auth/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(email);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSendMailToResetPassword(_response));
        });
    }

    protected processSendMailToResetPassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface IHealthClient {
    getBackendHealth(): Promise<boolean>;
}

export class HealthClient extends ClientBase implements IHealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthBase, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getBackendHealth(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetBackendHealth(_response));
        });
    }

    protected processGetBackendHealth(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export interface IMailClient {
    getAllMails(): Promise<EmailDto[]>;
    sendTestMail(command: SendTestMailCommand): Promise<FileResponse>;
    updateEmail(id: number, command: UpdateEmailCommand): Promise<FileResponse>;
    generatePreview(command: GeneratePreviewMailCommand): Promise<string>;
}

export class MailClient extends ClientBase implements IMailClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthBase, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllMails(): Promise<EmailDto[]> {
        let url_ = this.baseUrl + "/api/Mail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllMails(_response));
        });
    }

    protected processGetAllMails(response: Response): Promise<EmailDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmailDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmailDto[]>(<any>null);
    }

    sendTestMail(command: SendTestMailCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Mail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSendTestMail(_response));
        });
    }

    protected processSendTestMail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updateEmail(id: number, command: UpdateEmailCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Mail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateEmail(_response));
        });
    }

    protected processUpdateEmail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    generatePreview(command: GeneratePreviewMailCommand): Promise<string> {
        let url_ = this.baseUrl + "/api/Mail/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGeneratePreview(_response));
        });
    }

    protected processGeneratePreview(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export interface IStatementClient {
    getAllStatements(): Promise<StatementDto[]>;
    getMyStatements(): Promise<StatementDto[]>;
    getStatement(id: number): Promise<StatementDto>;
    updateStatement(id: number, command: UpdateStatementCommand): Promise<FileResponse>;
    createStatement(command: CreateStatementCommand): Promise<number>;
    signOffStatement(id: number): Promise<FileResponse>;
    getStatementsCSV(accountingYear?: number | null | undefined): Promise<CSVResponseDto>;
}

export class StatementClient extends ClientBase implements IStatementClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthBase, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllStatements(): Promise<StatementDto[]> {
        let url_ = this.baseUrl + "/api/Statement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllStatements(_response));
        });
    }

    protected processGetAllStatements(response: Response): Promise<StatementDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatementDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatementDto[]>(<any>null);
    }

    getMyStatements(): Promise<StatementDto[]> {
        let url_ = this.baseUrl + "/api/Statement/mystatements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetMyStatements(_response));
        });
    }

    protected processGetMyStatements(response: Response): Promise<StatementDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatementDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatementDto[]>(<any>null);
    }

    getStatement(id: number): Promise<StatementDto> {
        let url_ = this.baseUrl + "/api/Statement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetStatement(_response));
        });
    }

    protected processGetStatement(response: Response): Promise<StatementDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatementDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatementDto>(<any>null);
    }

    updateStatement(id: number, command: UpdateStatementCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Statement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateStatement(_response));
        });
    }

    protected processUpdateStatement(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    createStatement(command: CreateStatementCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Statement/statement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateStatement(_response));
        });
    }

    protected processCreateStatement(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    signOffStatement(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Statement/{id}/signoff";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSignOffStatement(_response));
        });
    }

    protected processSignOffStatement(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getStatementsCSV(accountingYear?: number | null | undefined): Promise<CSVResponseDto> {
        let url_ = this.baseUrl + "/api/Statement/csv?";
        if (accountingYear !== undefined && accountingYear !== null)
            url_ += "accountingYear=" + encodeURIComponent("" + accountingYear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetStatementsCSV(_response));
        });
    }

    protected processGetStatementsCSV(response: Response): Promise<CSVResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSVResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CSVResponseDto>(<any>null);
    }
}

export interface IUserClient {
    getCurrentUser(): Promise<UserDto>;
    getAllClients(): Promise<ClientDto[]>;
    createClient(command: CreateClientCommand): Promise<number>;
    getAllAdmins(): Promise<UserDto[]>;
    createAndAddAccountant(command: CreateAccountantCommand): Promise<number>;
    updateUser(id: number, command: UpdateUserCommand): Promise<FileResponse>;
    deactivateUser(id: number): Promise<FileResponse>;
    updatePassword(command: UpdatePasswordCommand): Promise<FileResponse>;
    resetPassword(command: ResetPasswordCommand): Promise<UserTokenDto>;
}

export class UserClient extends ClientBase implements IUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthBase, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCurrentUser(): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/User/currentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCurrentUser(_response));
        });
    }

    protected processGetCurrentUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }

    getAllClients(): Promise<ClientDto[]> {
        let url_ = this.baseUrl + "/api/User/clients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllClients(_response));
        });
    }

    protected processGetAllClients(response: Response): Promise<ClientDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientDto[]>(<any>null);
    }

    createClient(command: CreateClientCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/User/clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateClient(_response));
        });
    }

    protected processCreateClient(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    getAllAdmins(): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/User/admins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllAdmins(_response));
        });
    }

    protected processGetAllAdmins(response: Response): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto[]>(<any>null);
    }

    createAndAddAccountant(command: CreateAccountantCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/User/accountant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateAndAddAccountant(_response));
        });
    }

    protected processCreateAndAddAccountant(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    updateUser(id: number, command: UpdateUserCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateUser(_response));
        });
    }

    protected processUpdateUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    deactivateUser(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeactivateUser(_response));
        });
    }

    protected processDeactivateUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    updatePassword(command: UpdatePasswordCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/User/changePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdatePassword(_response));
        });
    }

    protected processUpdatePassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    resetPassword(command: ResetPasswordCommand): Promise<UserTokenDto> {
        let url_ = this.baseUrl + "/api/User/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processResetPassword(_response));
        });
    }

    protected processResetPassword(response: Response): Promise<UserTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTokenDto>(<any>null);
    }
}

export class UserTokenDto implements IUserTokenDto {
    user?: UserDto | null;
    token?: string | null;

    constructor(data?: IUserTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new UserDto(data.user) : <UserDto>this.user; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): UserTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface IUserTokenDto {
    user?: IUserDto | null;
    token?: string | null;
}

export class UserDto implements IUserDto {
    id?: number;
    email?: string | null;
    role?: RoleEnum;
    name?: string | null;
    deactivationTime?: Date | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.deactivationTime = _data["deactivationTime"] ? new Date(_data["deactivationTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["deactivationTime"] = this.deactivationTime ? this.deactivationTime.toISOString() : <any>null;
        return data; 
    }
}

export interface IUserDto {
    id?: number;
    email?: string | null;
    role?: RoleEnum;
    name?: string | null;
    deactivationTime?: Date | null;
}

export enum RoleEnum {
    Admin = 0,
    Accountant = 1,
    Client = 2,
}

export class LoginCommand implements ILoginCommand {
    loginDetails?: LoginRequestDto | null;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.loginDetails = data.loginDetails && !(<any>data.loginDetails).toJSON ? new LoginRequestDto(data.loginDetails) : <LoginRequestDto>this.loginDetails; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginDetails = _data["loginDetails"] ? LoginRequestDto.fromJS(_data["loginDetails"]) : <any>null;
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginDetails"] = this.loginDetails ? this.loginDetails.toJSON() : <any>null;
        return data; 
    }
}

export interface ILoginCommand {
    loginDetails?: ILoginRequestDto | null;
}

export class LoginRequestDto implements ILoginRequestDto {
    email?: string | null;
    password?: string | null;

    constructor(data?: ILoginRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface ILoginRequestDto {
    email?: string | null;
    password?: string | null;
}

export class EmailDto implements IEmailDto {
    id?: number;
    name?: string | null;
    subject?: string | null;
    heading1?: string | null;
    paragraph1?: string | null;
    heading2?: string | null;
    paragraph2?: string | null;
    heading3?: string | null;
    paragraph3?: string | null;
    ctaButtonText?: string | null;

    constructor(data?: IEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.subject = _data["subject"] !== undefined ? _data["subject"] : <any>null;
            this.heading1 = _data["heading1"] !== undefined ? _data["heading1"] : <any>null;
            this.paragraph1 = _data["paragraph1"] !== undefined ? _data["paragraph1"] : <any>null;
            this.heading2 = _data["heading2"] !== undefined ? _data["heading2"] : <any>null;
            this.paragraph2 = _data["paragraph2"] !== undefined ? _data["paragraph2"] : <any>null;
            this.heading3 = _data["heading3"] !== undefined ? _data["heading3"] : <any>null;
            this.paragraph3 = _data["paragraph3"] !== undefined ? _data["paragraph3"] : <any>null;
            this.ctaButtonText = _data["ctaButtonText"] !== undefined ? _data["ctaButtonText"] : <any>null;
        }
    }

    static fromJS(data: any): EmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["subject"] = this.subject !== undefined ? this.subject : <any>null;
        data["heading1"] = this.heading1 !== undefined ? this.heading1 : <any>null;
        data["paragraph1"] = this.paragraph1 !== undefined ? this.paragraph1 : <any>null;
        data["heading2"] = this.heading2 !== undefined ? this.heading2 : <any>null;
        data["paragraph2"] = this.paragraph2 !== undefined ? this.paragraph2 : <any>null;
        data["heading3"] = this.heading3 !== undefined ? this.heading3 : <any>null;
        data["paragraph3"] = this.paragraph3 !== undefined ? this.paragraph3 : <any>null;
        data["ctaButtonText"] = this.ctaButtonText !== undefined ? this.ctaButtonText : <any>null;
        return data; 
    }
}

export interface IEmailDto {
    id?: number;
    name?: string | null;
    subject?: string | null;
    heading1?: string | null;
    paragraph1?: string | null;
    heading2?: string | null;
    paragraph2?: string | null;
    heading3?: string | null;
    paragraph3?: string | null;
    ctaButtonText?: string | null;
}

export class UpdateEmailCommand implements IUpdateEmailCommand {
    newEmail?: EmailDto | null;

    constructor(data?: IUpdateEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.newEmail = data.newEmail && !(<any>data.newEmail).toJSON ? new EmailDto(data.newEmail) : <EmailDto>this.newEmail; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"] ? EmailDto.fromJS(_data["newEmail"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail ? this.newEmail.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateEmailCommand {
    newEmail?: IEmailDto | null;
}

export class SendTestMailCommand implements ISendTestMailCommand {

    constructor(data?: ISendTestMailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): SendTestMailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestMailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ISendTestMailCommand {
}

export class GeneratePreviewMailCommand implements IGeneratePreviewMailCommand {
    emailDto?: EmailDto | null;

    constructor(data?: IGeneratePreviewMailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.emailDto = data.emailDto && !(<any>data.emailDto).toJSON ? new EmailDto(data.emailDto) : <EmailDto>this.emailDto; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailDto = _data["emailDto"] ? EmailDto.fromJS(_data["emailDto"]) : <any>null;
        }
    }

    static fromJS(data: any): GeneratePreviewMailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new GeneratePreviewMailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailDto"] = this.emailDto ? this.emailDto.toJSON() : <any>null;
        return data; 
    }
}

export interface IGeneratePreviewMailCommand {
    emailDto?: IEmailDto | null;
}

export class StatementDto implements IStatementDto {
    id?: number;
    clientId?: number;
    client?: Client | null;
    accountantId?: number | null;
    accountant?: Accountant | null;
    accountingYear?: number;
    status?: StatementStatus;
    s1_mushrooms?: number;
    s1_tomatoCucumberHerb?: number;
    s1_boughtPlants?: number;
    s3_carrots?: number;
    s3_peas?: number;
    s3_onions?: number;
    s3_other?: number;
    s3_boughtPlants?: number;
    s4_onions?: number;
    s4_plants?: number;
    s4_cutFlowers?: number;
    s4_boughtPlants?: number;
    s7_plants?: number;
    s7_boughtPlants?: number;
    s8_applesPearsEtc?: number;
    s8_packaging?: number;
    s8_cherries?: number;
    s8_plums?: number;
    s8_otherStoneFruit?: number;
    s8_currant?: number;
    s8_strawberries?: number;
    s8_otherBerryFruit?: number;

    constructor(data?: IStatementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.client = data.client && !(<any>data.client).toJSON ? new Client(data.client) : <Client>this.client; 
            this.accountant = data.accountant && !(<any>data.accountant).toJSON ? new Accountant(data.accountant) : <Accountant>this.accountant; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>null;
            this.accountantId = _data["accountantId"] !== undefined ? _data["accountantId"] : <any>null;
            this.accountant = _data["accountant"] ? Accountant.fromJS(_data["accountant"]) : <any>null;
            this.accountingYear = _data["accountingYear"] !== undefined ? _data["accountingYear"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.s1_mushrooms = _data["s1_mushrooms"] !== undefined ? _data["s1_mushrooms"] : <any>null;
            this.s1_tomatoCucumberHerb = _data["s1_tomatoCucumberHerb"] !== undefined ? _data["s1_tomatoCucumberHerb"] : <any>null;
            this.s1_boughtPlants = _data["s1_boughtPlants"] !== undefined ? _data["s1_boughtPlants"] : <any>null;
            this.s3_carrots = _data["s3_carrots"] !== undefined ? _data["s3_carrots"] : <any>null;
            this.s3_peas = _data["s3_peas"] !== undefined ? _data["s3_peas"] : <any>null;
            this.s3_onions = _data["s3_onions"] !== undefined ? _data["s3_onions"] : <any>null;
            this.s3_other = _data["s3_other"] !== undefined ? _data["s3_other"] : <any>null;
            this.s3_boughtPlants = _data["s3_boughtPlants"] !== undefined ? _data["s3_boughtPlants"] : <any>null;
            this.s4_onions = _data["s4_onions"] !== undefined ? _data["s4_onions"] : <any>null;
            this.s4_plants = _data["s4_plants"] !== undefined ? _data["s4_plants"] : <any>null;
            this.s4_cutFlowers = _data["s4_cutFlowers"] !== undefined ? _data["s4_cutFlowers"] : <any>null;
            this.s4_boughtPlants = _data["s4_boughtPlants"] !== undefined ? _data["s4_boughtPlants"] : <any>null;
            this.s7_plants = _data["s7_plants"] !== undefined ? _data["s7_plants"] : <any>null;
            this.s7_boughtPlants = _data["s7_boughtPlants"] !== undefined ? _data["s7_boughtPlants"] : <any>null;
            this.s8_applesPearsEtc = _data["s8_applesPearsEtc"] !== undefined ? _data["s8_applesPearsEtc"] : <any>null;
            this.s8_packaging = _data["s8_packaging"] !== undefined ? _data["s8_packaging"] : <any>null;
            this.s8_cherries = _data["s8_cherries"] !== undefined ? _data["s8_cherries"] : <any>null;
            this.s8_plums = _data["s8_plums"] !== undefined ? _data["s8_plums"] : <any>null;
            this.s8_otherStoneFruit = _data["s8_otherStoneFruit"] !== undefined ? _data["s8_otherStoneFruit"] : <any>null;
            this.s8_currant = _data["s8_currant"] !== undefined ? _data["s8_currant"] : <any>null;
            this.s8_strawberries = _data["s8_strawberries"] !== undefined ? _data["s8_strawberries"] : <any>null;
            this.s8_otherBerryFruit = _data["s8_otherBerryFruit"] !== undefined ? _data["s8_otherBerryFruit"] : <any>null;
        }
    }

    static fromJS(data: any): StatementDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["client"] = this.client ? this.client.toJSON() : <any>null;
        data["accountantId"] = this.accountantId !== undefined ? this.accountantId : <any>null;
        data["accountant"] = this.accountant ? this.accountant.toJSON() : <any>null;
        data["accountingYear"] = this.accountingYear !== undefined ? this.accountingYear : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["s1_mushrooms"] = this.s1_mushrooms !== undefined ? this.s1_mushrooms : <any>null;
        data["s1_tomatoCucumberHerb"] = this.s1_tomatoCucumberHerb !== undefined ? this.s1_tomatoCucumberHerb : <any>null;
        data["s1_boughtPlants"] = this.s1_boughtPlants !== undefined ? this.s1_boughtPlants : <any>null;
        data["s3_carrots"] = this.s3_carrots !== undefined ? this.s3_carrots : <any>null;
        data["s3_peas"] = this.s3_peas !== undefined ? this.s3_peas : <any>null;
        data["s3_onions"] = this.s3_onions !== undefined ? this.s3_onions : <any>null;
        data["s3_other"] = this.s3_other !== undefined ? this.s3_other : <any>null;
        data["s3_boughtPlants"] = this.s3_boughtPlants !== undefined ? this.s3_boughtPlants : <any>null;
        data["s4_onions"] = this.s4_onions !== undefined ? this.s4_onions : <any>null;
        data["s4_plants"] = this.s4_plants !== undefined ? this.s4_plants : <any>null;
        data["s4_cutFlowers"] = this.s4_cutFlowers !== undefined ? this.s4_cutFlowers : <any>null;
        data["s4_boughtPlants"] = this.s4_boughtPlants !== undefined ? this.s4_boughtPlants : <any>null;
        data["s7_plants"] = this.s7_plants !== undefined ? this.s7_plants : <any>null;
        data["s7_boughtPlants"] = this.s7_boughtPlants !== undefined ? this.s7_boughtPlants : <any>null;
        data["s8_applesPearsEtc"] = this.s8_applesPearsEtc !== undefined ? this.s8_applesPearsEtc : <any>null;
        data["s8_packaging"] = this.s8_packaging !== undefined ? this.s8_packaging : <any>null;
        data["s8_cherries"] = this.s8_cherries !== undefined ? this.s8_cherries : <any>null;
        data["s8_plums"] = this.s8_plums !== undefined ? this.s8_plums : <any>null;
        data["s8_otherStoneFruit"] = this.s8_otherStoneFruit !== undefined ? this.s8_otherStoneFruit : <any>null;
        data["s8_currant"] = this.s8_currant !== undefined ? this.s8_currant : <any>null;
        data["s8_strawberries"] = this.s8_strawberries !== undefined ? this.s8_strawberries : <any>null;
        data["s8_otherBerryFruit"] = this.s8_otherBerryFruit !== undefined ? this.s8_otherBerryFruit : <any>null;
        return data; 
    }
}

export interface IStatementDto {
    id?: number;
    clientId?: number;
    client?: IClient | null;
    accountantId?: number | null;
    accountant?: IAccountant | null;
    accountingYear?: number;
    status?: StatementStatus;
    s1_mushrooms?: number;
    s1_tomatoCucumberHerb?: number;
    s1_boughtPlants?: number;
    s3_carrots?: number;
    s3_peas?: number;
    s3_onions?: number;
    s3_other?: number;
    s3_boughtPlants?: number;
    s4_onions?: number;
    s4_plants?: number;
    s4_cutFlowers?: number;
    s4_boughtPlants?: number;
    s7_plants?: number;
    s7_boughtPlants?: number;
    s8_applesPearsEtc?: number;
    s8_packaging?: number;
    s8_cherries?: number;
    s8_plums?: number;
    s8_otherStoneFruit?: number;
    s8_currant?: number;
    s8_strawberries?: number;
    s8_otherBerryFruit?: number;
}

export class AuditableEntity implements IAuditableEntity {
    createdBy?: string | null;
    created?: Date;
    lastModifiedBy?: string | null;
    lastModified?: Date | null;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.lastModifiedBy = _data["lastModifiedBy"] !== undefined ? _data["lastModifiedBy"] : <any>null;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["lastModifiedBy"] = this.lastModifiedBy !== undefined ? this.lastModifiedBy : <any>null;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>null;
        return data; 
    }
}

export interface IAuditableEntity {
    createdBy?: string | null;
    created?: Date;
    lastModifiedBy?: string | null;
    lastModified?: Date | null;
}

export abstract class User extends AuditableEntity implements IUser {
    id?: number;
    email?: string | null;
    password?: string | null;
    name?: string | null;
    role?: RoleEnum;
    deactivationTime?: Date | null;
    ssoTokenId?: string | null;

    constructor(data?: IUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.deactivationTime = _data["deactivationTime"] ? new Date(_data["deactivationTime"].toString()) : <any>null;
            this.ssoTokenId = _data["ssoTokenId"] !== undefined ? _data["ssoTokenId"] : <any>null;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'User' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["deactivationTime"] = this.deactivationTime ? this.deactivationTime.toISOString() : <any>null;
        data["ssoTokenId"] = this.ssoTokenId !== undefined ? this.ssoTokenId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUser extends IAuditableEntity {
    id?: number;
    email?: string | null;
    password?: string | null;
    name?: string | null;
    role?: RoleEnum;
    deactivationTime?: Date | null;
    ssoTokenId?: string | null;
}

export class Client extends User implements IClient {
    tel?: string | null;
    addressId?: number | null;
    address?: Address | null;
    cvrNumber?: string | null;
    statements?: Statement[] | null;
    role?: RoleEnum;

    constructor(data?: IClient) {
        super(data);
        if (data) {
            this.address = data.address && !(<any>data.address).toJSON ? new Address(data.address) : <Address>this.address; 
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tel = _data["tel"] !== undefined ? _data["tel"] : <any>null;
            this.addressId = _data["addressId"] !== undefined ? _data["addressId"] : <any>null;
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : <any>null;
            this.cvrNumber = _data["cvrNumber"] !== undefined ? _data["cvrNumber"] : <any>null;
            if (Array.isArray(_data["statements"])) {
                this.statements = [] as any;
                for (let item of _data["statements"])
                    this.statements!.push(Statement.fromJS(item));
            }
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tel"] = this.tel !== undefined ? this.tel : <any>null;
        data["addressId"] = this.addressId !== undefined ? this.addressId : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["cvrNumber"] = this.cvrNumber !== undefined ? this.cvrNumber : <any>null;
        if (Array.isArray(this.statements)) {
            data["statements"] = [];
            for (let item of this.statements)
                data["statements"].push(item.toJSON());
        }
        data["role"] = this.role !== undefined ? this.role : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IClient extends IUser {
    tel?: string | null;
    addressId?: number | null;
    address?: IAddress | null;
    cvrNumber?: string | null;
    statements?: Statement[] | null;
    role?: RoleEnum;
}

export class Address implements IAddress {
    id?: number;
    clientId?: number;
    client?: Client | null;
    addressLine1?: string | null;
    addressLine2?: string | null;
    addressLine3?: string | null;
    addressLine4?: string | null;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.client = data.client && !(<any>data.client).toJSON ? new Client(data.client) : <Client>this.client; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>null;
            this.addressLine1 = _data["addressLine1"] !== undefined ? _data["addressLine1"] : <any>null;
            this.addressLine2 = _data["addressLine2"] !== undefined ? _data["addressLine2"] : <any>null;
            this.addressLine3 = _data["addressLine3"] !== undefined ? _data["addressLine3"] : <any>null;
            this.addressLine4 = _data["addressLine4"] !== undefined ? _data["addressLine4"] : <any>null;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["client"] = this.client ? this.client.toJSON() : <any>null;
        data["addressLine1"] = this.addressLine1 !== undefined ? this.addressLine1 : <any>null;
        data["addressLine2"] = this.addressLine2 !== undefined ? this.addressLine2 : <any>null;
        data["addressLine3"] = this.addressLine3 !== undefined ? this.addressLine3 : <any>null;
        data["addressLine4"] = this.addressLine4 !== undefined ? this.addressLine4 : <any>null;
        return data; 
    }
}

export interface IAddress {
    id?: number;
    clientId?: number;
    client?: IClient | null;
    addressLine1?: string | null;
    addressLine2?: string | null;
    addressLine3?: string | null;
    addressLine4?: string | null;
}

export class Statement extends AuditableEntity implements IStatement {
    id?: number;
    clientId?: number;
    client?: Client | null;
    accountantId?: number | null;
    accountant?: Accountant | null;
    accountantType?: AccountantType;
    accountingYear?: number;
    status?: StatementStatus;
    s1_mushrooms?: number;
    s1_tomatoCucumberHerb?: number;
    s1_boughtPlants?: number;
    s3_carrots?: number;
    s3_peas?: number;
    s3_onions?: number;
    s3_other?: number;
    s3_boughtPlants?: number;
    s4_onions?: number;
    s4_plants?: number;
    s4_cutFlowers?: number;
    s4_boughtPlants?: number;
    s7_plants?: number;
    s7_boughtPlants?: number;
    s8_applesPearsEtc?: number;
    s8_packaging?: number;
    s8_cherries?: number;
    s8_plums?: number;
    s8_otherStoneFruit?: number;
    s8_currant?: number;
    s8_strawberries?: number;
    s8_otherBerryFruit?: number;

    constructor(data?: IStatement) {
        super(data);
        if (data) {
            this.client = data.client && !(<any>data.client).toJSON ? new Client(data.client) : <Client>this.client; 
            this.accountant = data.accountant && !(<any>data.accountant).toJSON ? new Accountant(data.accountant) : <Accountant>this.accountant; 
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>null;
            this.accountantId = _data["accountantId"] !== undefined ? _data["accountantId"] : <any>null;
            this.accountant = _data["accountant"] ? Accountant.fromJS(_data["accountant"]) : <any>null;
            this.accountantType = _data["accountantType"] !== undefined ? _data["accountantType"] : <any>null;
            this.accountingYear = _data["accountingYear"] !== undefined ? _data["accountingYear"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.s1_mushrooms = _data["s1_mushrooms"] !== undefined ? _data["s1_mushrooms"] : <any>null;
            this.s1_tomatoCucumberHerb = _data["s1_tomatoCucumberHerb"] !== undefined ? _data["s1_tomatoCucumberHerb"] : <any>null;
            this.s1_boughtPlants = _data["s1_boughtPlants"] !== undefined ? _data["s1_boughtPlants"] : <any>null;
            this.s3_carrots = _data["s3_carrots"] !== undefined ? _data["s3_carrots"] : <any>null;
            this.s3_peas = _data["s3_peas"] !== undefined ? _data["s3_peas"] : <any>null;
            this.s3_onions = _data["s3_onions"] !== undefined ? _data["s3_onions"] : <any>null;
            this.s3_other = _data["s3_other"] !== undefined ? _data["s3_other"] : <any>null;
            this.s3_boughtPlants = _data["s3_boughtPlants"] !== undefined ? _data["s3_boughtPlants"] : <any>null;
            this.s4_onions = _data["s4_onions"] !== undefined ? _data["s4_onions"] : <any>null;
            this.s4_plants = _data["s4_plants"] !== undefined ? _data["s4_plants"] : <any>null;
            this.s4_cutFlowers = _data["s4_cutFlowers"] !== undefined ? _data["s4_cutFlowers"] : <any>null;
            this.s4_boughtPlants = _data["s4_boughtPlants"] !== undefined ? _data["s4_boughtPlants"] : <any>null;
            this.s7_plants = _data["s7_plants"] !== undefined ? _data["s7_plants"] : <any>null;
            this.s7_boughtPlants = _data["s7_boughtPlants"] !== undefined ? _data["s7_boughtPlants"] : <any>null;
            this.s8_applesPearsEtc = _data["s8_applesPearsEtc"] !== undefined ? _data["s8_applesPearsEtc"] : <any>null;
            this.s8_packaging = _data["s8_packaging"] !== undefined ? _data["s8_packaging"] : <any>null;
            this.s8_cherries = _data["s8_cherries"] !== undefined ? _data["s8_cherries"] : <any>null;
            this.s8_plums = _data["s8_plums"] !== undefined ? _data["s8_plums"] : <any>null;
            this.s8_otherStoneFruit = _data["s8_otherStoneFruit"] !== undefined ? _data["s8_otherStoneFruit"] : <any>null;
            this.s8_currant = _data["s8_currant"] !== undefined ? _data["s8_currant"] : <any>null;
            this.s8_strawberries = _data["s8_strawberries"] !== undefined ? _data["s8_strawberries"] : <any>null;
            this.s8_otherBerryFruit = _data["s8_otherBerryFruit"] !== undefined ? _data["s8_otherBerryFruit"] : <any>null;
        }
    }

    static fromJS(data: any): Statement {
        data = typeof data === 'object' ? data : {};
        let result = new Statement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["client"] = this.client ? this.client.toJSON() : <any>null;
        data["accountantId"] = this.accountantId !== undefined ? this.accountantId : <any>null;
        data["accountant"] = this.accountant ? this.accountant.toJSON() : <any>null;
        data["accountantType"] = this.accountantType !== undefined ? this.accountantType : <any>null;
        data["accountingYear"] = this.accountingYear !== undefined ? this.accountingYear : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["s1_mushrooms"] = this.s1_mushrooms !== undefined ? this.s1_mushrooms : <any>null;
        data["s1_tomatoCucumberHerb"] = this.s1_tomatoCucumberHerb !== undefined ? this.s1_tomatoCucumberHerb : <any>null;
        data["s1_boughtPlants"] = this.s1_boughtPlants !== undefined ? this.s1_boughtPlants : <any>null;
        data["s3_carrots"] = this.s3_carrots !== undefined ? this.s3_carrots : <any>null;
        data["s3_peas"] = this.s3_peas !== undefined ? this.s3_peas : <any>null;
        data["s3_onions"] = this.s3_onions !== undefined ? this.s3_onions : <any>null;
        data["s3_other"] = this.s3_other !== undefined ? this.s3_other : <any>null;
        data["s3_boughtPlants"] = this.s3_boughtPlants !== undefined ? this.s3_boughtPlants : <any>null;
        data["s4_onions"] = this.s4_onions !== undefined ? this.s4_onions : <any>null;
        data["s4_plants"] = this.s4_plants !== undefined ? this.s4_plants : <any>null;
        data["s4_cutFlowers"] = this.s4_cutFlowers !== undefined ? this.s4_cutFlowers : <any>null;
        data["s4_boughtPlants"] = this.s4_boughtPlants !== undefined ? this.s4_boughtPlants : <any>null;
        data["s7_plants"] = this.s7_plants !== undefined ? this.s7_plants : <any>null;
        data["s7_boughtPlants"] = this.s7_boughtPlants !== undefined ? this.s7_boughtPlants : <any>null;
        data["s8_applesPearsEtc"] = this.s8_applesPearsEtc !== undefined ? this.s8_applesPearsEtc : <any>null;
        data["s8_packaging"] = this.s8_packaging !== undefined ? this.s8_packaging : <any>null;
        data["s8_cherries"] = this.s8_cherries !== undefined ? this.s8_cherries : <any>null;
        data["s8_plums"] = this.s8_plums !== undefined ? this.s8_plums : <any>null;
        data["s8_otherStoneFruit"] = this.s8_otherStoneFruit !== undefined ? this.s8_otherStoneFruit : <any>null;
        data["s8_currant"] = this.s8_currant !== undefined ? this.s8_currant : <any>null;
        data["s8_strawberries"] = this.s8_strawberries !== undefined ? this.s8_strawberries : <any>null;
        data["s8_otherBerryFruit"] = this.s8_otherBerryFruit !== undefined ? this.s8_otherBerryFruit : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IStatement extends IAuditableEntity {
    id?: number;
    clientId?: number;
    client?: IClient | null;
    accountantId?: number | null;
    accountant?: IAccountant | null;
    accountantType?: AccountantType;
    accountingYear?: number;
    status?: StatementStatus;
    s1_mushrooms?: number;
    s1_tomatoCucumberHerb?: number;
    s1_boughtPlants?: number;
    s3_carrots?: number;
    s3_peas?: number;
    s3_onions?: number;
    s3_other?: number;
    s3_boughtPlants?: number;
    s4_onions?: number;
    s4_plants?: number;
    s4_cutFlowers?: number;
    s4_boughtPlants?: number;
    s7_plants?: number;
    s7_boughtPlants?: number;
    s8_applesPearsEtc?: number;
    s8_packaging?: number;
    s8_cherries?: number;
    s8_plums?: number;
    s8_otherStoneFruit?: number;
    s8_currant?: number;
    s8_strawberries?: number;
    s8_otherBerryFruit?: number;
}

export class Accountant extends User implements IAccountant {
    role?: RoleEnum;
    accountantType?: AccountantType;
    statements?: Statement[] | null;

    constructor(data?: IAccountant) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.accountantType = _data["accountantType"] !== undefined ? _data["accountantType"] : <any>null;
            if (Array.isArray(_data["statements"])) {
                this.statements = [] as any;
                for (let item of _data["statements"])
                    this.statements!.push(Statement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Accountant {
        data = typeof data === 'object' ? data : {};
        let result = new Accountant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["accountantType"] = this.accountantType !== undefined ? this.accountantType : <any>null;
        if (Array.isArray(this.statements)) {
            data["statements"] = [];
            for (let item of this.statements)
                data["statements"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAccountant extends IUser {
    role?: RoleEnum;
    accountantType?: AccountantType;
    statements?: Statement[] | null;
}

export enum AccountantType {
    Accountant = 0,
    Consultant = 1,
}

export enum StatementStatus {
    InvitedNotEdited = 0,
    InvitedAndEdited = 1,
    SignedOff = 2,
}

export class CreateStatementCommand implements ICreateStatementCommand {
    clientId?: number;
    revisionYear?: number;

    constructor(data?: ICreateStatementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.revisionYear = _data["revisionYear"] !== undefined ? _data["revisionYear"] : <any>null;
        }
    }

    static fromJS(data: any): CreateStatementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStatementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["revisionYear"] = this.revisionYear !== undefined ? this.revisionYear : <any>null;
        return data; 
    }
}

export interface ICreateStatementCommand {
    clientId?: number;
    revisionYear?: number;
}

export class UpdateStatementCommand implements IUpdateStatementCommand {
    statementDto?: StatementDto | null;

    constructor(data?: IUpdateStatementCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.statementDto = data.statementDto && !(<any>data.statementDto).toJSON ? new StatementDto(data.statementDto) : <StatementDto>this.statementDto; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statementDto = _data["statementDto"] ? StatementDto.fromJS(_data["statementDto"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateStatementCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatementCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statementDto"] = this.statementDto ? this.statementDto.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateStatementCommand {
    statementDto?: IStatementDto | null;
}

export class CSVResponseDto implements ICSVResponseDto {
    fileName?: string | null;
    content?: string | null;

    constructor(data?: ICSVResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.content = _data["content"] !== undefined ? _data["content"] : <any>null;
        }
    }

    static fromJS(data: any): CSVResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CSVResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["content"] = this.content !== undefined ? this.content : <any>null;
        return data; 
    }
}

export interface ICSVResponseDto {
    fileName?: string | null;
    content?: string | null;
}

export class ClientDto extends UserDto implements IClientDto {
    tel?: string | null;
    address?: AddressDto | null;
    cvrNumber?: string | null;
    statements?: StatementDto[] | null;

    constructor(data?: IClientDto) {
        super(data);
        if (data) {
            this.address = data.address && !(<any>data.address).toJSON ? new AddressDto(data.address) : <AddressDto>this.address; 
            if (data.statements) {
                this.statements = [];
                for (let i = 0; i < data.statements.length; i++) {
                    let item = data.statements[i];
                    this.statements[i] = item && !(<any>item).toJSON ? new StatementDto(item) : <StatementDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tel = _data["tel"] !== undefined ? _data["tel"] : <any>null;
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>null;
            this.cvrNumber = _data["cvrNumber"] !== undefined ? _data["cvrNumber"] : <any>null;
            if (Array.isArray(_data["statements"])) {
                this.statements = [] as any;
                for (let item of _data["statements"])
                    this.statements!.push(StatementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tel"] = this.tel !== undefined ? this.tel : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["cvrNumber"] = this.cvrNumber !== undefined ? this.cvrNumber : <any>null;
        if (Array.isArray(this.statements)) {
            data["statements"] = [];
            for (let item of this.statements)
                data["statements"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IClientDto extends IUserDto {
    tel?: string | null;
    address?: IAddressDto | null;
    cvrNumber?: string | null;
    statements?: IStatementDto[] | null;
}

export class AddressDto implements IAddressDto {
    addressLine1?: string | null;
    addressLine2?: string | null;
    addressLine3?: string | null;
    addressLine4?: string | null;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressLine1 = _data["addressLine1"] !== undefined ? _data["addressLine1"] : <any>null;
            this.addressLine2 = _data["addressLine2"] !== undefined ? _data["addressLine2"] : <any>null;
            this.addressLine3 = _data["addressLine3"] !== undefined ? _data["addressLine3"] : <any>null;
            this.addressLine4 = _data["addressLine4"] !== undefined ? _data["addressLine4"] : <any>null;
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressLine1"] = this.addressLine1 !== undefined ? this.addressLine1 : <any>null;
        data["addressLine2"] = this.addressLine2 !== undefined ? this.addressLine2 : <any>null;
        data["addressLine3"] = this.addressLine3 !== undefined ? this.addressLine3 : <any>null;
        data["addressLine4"] = this.addressLine4 !== undefined ? this.addressLine4 : <any>null;
        return data; 
    }
}

export interface IAddressDto {
    addressLine1?: string | null;
    addressLine2?: string | null;
    addressLine3?: string | null;
    addressLine4?: string | null;
}

export class CreateClientCommand implements ICreateClientCommand {
    clientDto?: ClientDto | null;

    constructor(data?: ICreateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.clientDto = data.clientDto && !(<any>data.clientDto).toJSON ? new ClientDto(data.clientDto) : <ClientDto>this.clientDto; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientDto = _data["clientDto"] ? ClientDto.fromJS(_data["clientDto"]) : <any>null;
        }
    }

    static fromJS(data: any): CreateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientDto"] = this.clientDto ? this.clientDto.toJSON() : <any>null;
        return data; 
    }
}

export interface ICreateClientCommand {
    clientDto?: IClientDto | null;
}

export class CreateAccountantCommand implements ICreateAccountantCommand {
    accountantDto?: AccountantDto | null;
    statementId?: number;

    constructor(data?: ICreateAccountantCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.accountantDto = data.accountantDto && !(<any>data.accountantDto).toJSON ? new AccountantDto(data.accountantDto) : <AccountantDto>this.accountantDto; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountantDto = _data["accountantDto"] ? AccountantDto.fromJS(_data["accountantDto"]) : <any>null;
            this.statementId = _data["statementId"] !== undefined ? _data["statementId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateAccountantCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountantCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountantDto"] = this.accountantDto ? this.accountantDto.toJSON() : <any>null;
        data["statementId"] = this.statementId !== undefined ? this.statementId : <any>null;
        return data; 
    }
}

export interface ICreateAccountantCommand {
    accountantDto?: IAccountantDto | null;
    statementId?: number;
}

export class AccountantDto extends UserDto implements IAccountantDto {
    accountantType?: AccountantType;
    statements?: StatementDto[] | null;

    constructor(data?: IAccountantDto) {
        super(data);
        if (data) {
            if (data.statements) {
                this.statements = [];
                for (let i = 0; i < data.statements.length; i++) {
                    let item = data.statements[i];
                    this.statements[i] = item && !(<any>item).toJSON ? new StatementDto(item) : <StatementDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accountantType = _data["accountantType"] !== undefined ? _data["accountantType"] : <any>null;
            if (Array.isArray(_data["statements"])) {
                this.statements = [] as any;
                for (let item of _data["statements"])
                    this.statements!.push(StatementDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountantDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountantType"] = this.accountantType !== undefined ? this.accountantType : <any>null;
        if (Array.isArray(this.statements)) {
            data["statements"] = [];
            for (let item of this.statements)
                data["statements"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IAccountantDto extends IUserDto {
    accountantType?: AccountantType;
    statements?: IStatementDto[] | null;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    user?: UserDto | null;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new UserDto(data.user) : <UserDto>this.user; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateUserCommand {
    user?: IUserDto | null;
}

export class UpdatePasswordCommand implements IUpdatePasswordCommand {
    newPassword?: string | null;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"] !== undefined ? _data["newPassword"] : <any>null;
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        return data; 
    }
}

export interface IUpdatePasswordCommand {
    newPassword?: string | null;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    ssoToken?: string | null;
    newPassword?: string | null;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ssoToken = _data["ssoToken"] !== undefined ? _data["ssoToken"] : <any>null;
            this.newPassword = _data["newPassword"] !== undefined ? _data["newPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ssoToken"] = this.ssoToken !== undefined ? this.ssoToken : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        return data; 
    }
}

export interface IResetPasswordCommand {
    ssoToken?: string | null;
    newPassword?: string | null;
}

export enum CommandErrorCode {
    AbstractComparisonValidator = 0,
    AsyncPredicateValidator = 1,
    AsyncValidatorBase = 2,
    ChildValidatorAdaptor = 3,
    CreditCardValidator = 4,
    CustomValidator = 5,
    EmailValidator = 6,
    EmptyValidator = 7,
    EnumValidator = 8,
    EqualValidator = 9,
    ExclusiveBetweenValidator = 10,
    GreaterThanOrEqualValidator = 11,
    GreaterThanValidator = 12,
    IPropertyValidator = 13,
    InclusiveBetweenValidator = 14,
    LengthValidator = 15,
    LessThanOrEqualValidator = 16,
    LessThanValidator = 17,
    NoopPropertyValidator = 18,
    NotEmptyValidator = 19,
    NotEqualValidator = 20,
    NotNullValidator = 21,
    NullValidator = 22,
    OnFailureValidator = 23,
    PolymorphicValidator = 24,
    PredicateValidator = 25,
    PropertyValidator = 26,
    PropertyValidatorContext = 27,
    RegularExpressionValidator = 28,
    ScalePrecisionValidator = 29,
    StringEnumValidator = 30,
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

/* istanbul ignore file */